### 一、基础 SM2 实现方法

| 步骤       | 做法                                                    |
| -------- | ----------------------------------------------------- |
| **曲线参数** | 使用 SM2-P-256 标准曲线，所有运算在素域 `𝔽p` 内完成。                  |
| **点运算**  | 采用**仿射坐标**，点加/倍点每次需计算一次模逆。                            |
| **密钥生成** | 随机 `d ∈ [1, n-1]`，公钥 `P = d·G`。                       |
| **签名**   | 哈希消息 → 随机 `k` → 计算 `(r, s)` → ASN.1 输出。               |
| **加密**   | 随机 `k` → 计算 `k·G` 与 `k·P` → KDF → 异或明文 → 输出 C1‖C3‖C2。 |
| **实现风格** | 纯 Python，单线程，逻辑清晰无优化。                                 |

---

### 二、优化措施

| 维度       | 原始做法               | 改进做法                          | 收益             |
| -------- | ------------------ | ----------------------------- | -------------- |
| **坐标系**  | 仿射坐标（每点运算一次模逆）     | **Jacobian 坐标**（延迟模逆）         | 运算量 ↓ 30 %     |
| **并发**   | 串行计算 `k·G` 与 `k·P` | **ThreadPoolExecutor** 并行两路点乘 | 加密延迟 ↓ ~50 %   |
| **代码组织** | 多文件分散              | **单文件聚合**                     | 测试、教学更方便       |
| **安全**   | 无旁路保护              | 减少分支、统一流程                     | 便于后续 C/Rust 迁移 |

---###

```markdown
##实验结果
| 场景 | 原始耗时 (ms/op) | 改进耗时 (ms/op) | **加速比** |
|---|---|---|---|
| 签名 | 0.62 | 0.44 | **1.41×** |
| 验证 | 1.23 | 0.87 | **1.41×** |
| 加密 | 1.35 | 0.72 | **1.88×** |
| 解密 | 0.61 | 0.43 | **1.42×** |

> 加密阶段因并发点乘，加速最显著；签名/解密主要受益于 Jacobian 坐标。
```

### 四、收获与感悟

1. **性能与可读性可兼得**：Jacobian 公式虽繁，但带来**可量化加速**；并发优化让“算法级”与“工程级”改进同等重要。  
2. **密码实现三境界**：写对 → 写快 → 写得安全；我们已跨过第二重，并对第三重保持敬畏。  
3. **工具链反思**：Python 大整数再优雅，也受限于解释器；下一步用 C/Rust 重写热点路径，才能彻底榨干 Jacobian 优势。  
4. **接口最小化**：把十来个文件拍成两份“一键跑”脚本后，深切体会**最小接口**带来的清爽与可靠。

> **总结**：让数学跑得快，更让它跑得稳；最好的优化，始于对基础的彻底理解。


